//go:build ignore

package widgets
package widgets


























































}	}, nil		FetchedAt:   time.Now().Unix(),		WeatherCode: payload.Current.WeatherCode,		Temperature: payload.Current.Temperature,		City:        city,	return Weather{	}		return Weather{}, err	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {	}		} `json:"current"`			WeatherCode int     `json:"weather_code"`			Temperature float64 `json:"temperature_2m"`		Current struct {	var payload struct {	}		return Weather{}, errors.New("bad status")	if resp.StatusCode < 200 || resp.StatusCode >= 300 {	defer resp.Body.Close()	}		return Weather{}, err	if err != nil {	resp, err := client.Do(req)	client := &http.Client{Timeout: 10 * time.Second}	req.Header.Set("User-Agent", "Hearth/0.1")	req, _ := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)	endpoint := "https://api.open-meteo.com/v1/forecast?" + q.Encode()	q.Set("timezone", "auto")	q.Set("current", "temperature_2m,weather_code")	q.Set("longitude", lon)	q.Set("latitude", lat)	q := url.Values{}	}		return Weather{}, errors.New("weather lat/lon not configured")	if lat == "" || lon == "" {func FetchOpenMeteo(ctx context.Context, lat, lon, city string) (Weather, error) {// Uses Open-Meteo current weather (no API key).}	FetchedAt   int64   `json:"fetchedAt"`	WeatherCode int     `json:"weatherCode"`	Temperature float64 `json:"temperatureC"`	City        string  `json:"city"`type Weather struct {)	"time"	"net/url"	"net/http"	"errors"	"encoding/json"	"context"import (